#include <libspotify/api.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "spotify.h"

#define USER_AGENT "Futify"
#define VERSION "0.1"

struct spotify_s {
	sp_session *session;
};

static void logged_in(sp_session *session, sp_error error);
static void logged_out(sp_session *session);
static void metadata_updated(sp_session *session);
static void connection_error(sp_session *session, sp_error error);
static void message_to_user(sp_session *session, const char *message);
static void notify_main_thread(sp_session *session);
static int music_delivery(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames);
static void play_token_lost(sp_session *session);
static void log_message(sp_session *session, const char *data);
static void end_of_track(sp_session *session);
static void streaming_error(sp_session *session, sp_error error);
static void userinfo_updated(sp_session *session);
static void start_playback(sp_session *session);
static void stop_playback(sp_session *session);
static void get_audio_buffer_stats(sp_session *session, sp_audio_buffer_stats *stats);
static void offline_status_updated(sp_session *session);
static void offline_error(sp_session *session, sp_error error);
static void credentials_blob_updated(sp_session *session, const char *blob);
static void connectionstate_updated(sp_session *session);
static void scrobble_error(sp_session *session, sp_error error);
static void private_session_mode_changed(sp_session *session, bool is_private);

static sp_session_callbacks callbacks = {
	&logged_in,
	&logged_out,
	&metadata_updated,
	&connection_error,
	&message_to_user,
	&notify_main_thread,
	&music_delivery,
	&play_token_lost,
	&log_message,
	&end_of_track,
	&streaming_error,
	&userinfo_updated,
	&start_playback,
	&stop_playback,
	&get_audio_buffer_stats,
	&offline_status_updated,
	&offline_error,
	&credentials_blob_updated,
	&connectionstate_updated,
	&scrobble_error,
	&private_session_mode_changed
};

spotify_t *
spotify_init(const char *username, const char *password, int *error)
{
	spotify_t *spotify;
	sp_session_config config;
	sp_error sp_error;
	sp_session *session;

	memset(&config, 0, sizeof(sp_session_config));
	memset(&sp_error, 0, sizeof(sp_error));
	session = NULL;

	if (error) *error = 0;
	spotify = calloc(1, sizeof(spotify_t));
	if (!spotify) {
		if (error) *error = 1;
		return NULL;
	}
	
	/// The application key is specific to each project, and allows Spotify
	/// to produce statistics on how our service is used.
	extern const char g_appkey[];
	/// The size of the application key.
	extern const size_t g_appkey_size;

	// Always do this. It allows libspotify to check for
	// header/library inconsistencies.
	config.api_version = SPOTIFY_API_VERSION;

	// The path of the directory to store the cache. This must be specified.
	// Please read the documentation on preferred values.
	config.cache_location = "tmp";

	// The path of the directory to store the settings. 
	// This must be specified.
	// Please read the documentation on preferred values.
	config.settings_location = "tmp";

	// The key of the application. They are generated by Spotify,
	// and are specific to each application using libspotify.
	config.application_key = g_appkey;
	config.application_key_size = g_appkey_size;

	// This identifies the application using some
	// free-text string [1, 255] characters.
	config.user_agent = USER_AGENT" "VERSION;

	// Register the callbacks.
	config.callbacks = &callbacks;

	// Set the userdata to our spotify handle
	config.userdata = spotify;

	sp_error = sp_session_create(&config, &session);
	if (sp_error != SP_ERROR_OK) {
		fprintf(stderr, "failed to create session: %s\n",
		                sp_error_message(sp_error));
		if (error) *error = 2;
		return NULL;
	}

	// Login using the credentials given.
	sp_error = sp_session_login(session, username, password, 0, NULL);

	if (sp_error != SP_ERROR_OK) {
		sp_session_release(session);
		fprintf(stderr, "failed to login: %s\n",
		                sp_error_message(sp_error));
		if (error) *error = 3;
		return NULL;
	}

	spotify->session = session;
	return spotify;
}

void
spotify_destroy(spotify_t *spotify)
{
	if (spotify) {
		sp_session_release(spotify->session);
	}
	free(spotify);
}

void
spotify_run(spotify_t *spotify)
{
	if (!spotify) {
		return;
	}
}




static void
logged_in(sp_session *session, sp_error error)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
logged_out(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
metadata_updated(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
connection_error(sp_session *session, sp_error error)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
message_to_user(sp_session *session, const char *message)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
notify_main_thread(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static int
music_delivery(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
play_token_lost(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
log_message(sp_session *session, const char *data)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);

	fprintf(stderr, "%s", data);
}
static void
end_of_track(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
streaming_error(sp_session *session, sp_error error)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
userinfo_updated(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
start_playback(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
stop_playback(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
get_audio_buffer_stats(sp_session *session, sp_audio_buffer_stats *stats)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
offline_status_updated(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
offline_error(sp_session *session, sp_error error)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
credentials_blob_updated(sp_session *session, const char *blob)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
connectionstate_updated(sp_session *session)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
scrobble_error(sp_session *session, sp_error error)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}
static void
private_session_mode_changed(sp_session *session, bool is_private)
{
	spotify_t *spotify;

	assert(spotify);
	spotify = sp_session_userdata(session);
}

